


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > StandardGameController</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">controller</a>
</div>

<h1>Coverage Summary for Class: StandardGameController (controller)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">StandardGameController</td>
<td class="coverageStat">
  <span class="percent">
    96%
  </span>
  <span class="absValue">
    (24/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.2%
  </span>
  <span class="absValue">
    (221/245)
  </span>
</td>
</tr>
  <tr>
    <td class="name">StandardGameController$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StandardGameController$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StandardGameController$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StandardGameController$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StandardGameController$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StandardGameController$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StandardGameController$7</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    97.4%
  </span>
  <span class="absValue">
    (38/39)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.6%
  </span>
  <span class="absValue">
    (261/285)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package controller;
&nbsp;
&nbsp;import controller.exceptions.GameAccessDeniedException;
&nbsp;import controller.interfaces.GameController;
&nbsp;import controller.interfaces.LobbyController;
&nbsp;import distibuted.interfaces.ClientInterface;
&nbsp;import model.Tile;
&nbsp;import model.Token;
&nbsp;import model.User;
&nbsp;import model.abstractModel.*;
&nbsp;import model.exceptions.GameEndedException;
&nbsp;import model.exceptions.MatchmakingClosedException;
&nbsp;import model.exceptions.PlayerAlreadyExistsException;
&nbsp;import model.exceptions.PlayerNotExistsException;
&nbsp;import modelView.PickedTile;
&nbsp;import modelView.PlayerMoveInfo;
&nbsp;import util.Observable;
&nbsp;import util.Observer;
&nbsp;import util.TimedLock;
&nbsp;
&nbsp;import java.rmi.RemoteException;
&nbsp;import java.util.*;
&nbsp;import java.util.function.Consumer;
&nbsp;
&nbsp;/**
&nbsp; * This is a combined implementation of a {@link LobbyController} and a {@link GameController}
&nbsp; * &lt;p&gt;
&nbsp; * The game rules implemented follow the standard rules
&nbsp; */
&nbsp;@SuppressWarnings(&quot;rawtypes&quot;)
&nbsp;public class StandardGameController implements GameController, LobbyController {
&nbsp;    /**
&nbsp;     * The model of the game this controller is interacting with
&nbsp;     */
&nbsp;    private final Game game;
&nbsp;
&nbsp;    /**
&nbsp;     * Map of association between a client and its user reference on the server
&nbsp;     */
&nbsp;    private final Map&lt;ClientInterface, User&gt; userAssociation;
&nbsp;
&nbsp;    /**
&nbsp;     * Map of association between a user reference on the server and its playerID into game model
&nbsp;     */
&nbsp;    private final Map&lt;User, String&gt; playerAssociation;
&nbsp;
&nbsp;    /**
&nbsp;     * Map of association between a client and all the observers it is attached to, observers are also associated with
&nbsp;     * the observable they are attached to.
&nbsp;     * This object is mainly used when a client needs to be detached from the game
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;rawtypes&quot;)
&nbsp;    private final Map&lt;ClientInterface, Map&lt;Observable, Observer&gt;&gt; observerAssociation;
&nbsp;
&nbsp;    /**
&nbsp;     * Consumer called after the game has been definitely closed. This allows to notify who generated this instance that
&nbsp;     * this game controller is no longer useful
&nbsp;     */
&nbsp;    private final Consumer&lt;? super LobbyController&gt; gameClosedCallback;
&nbsp;
&nbsp;    /**
&nbsp;     * The timed lock used by lobby controller to control leave and join flow
&nbsp;     */
<b class="fc">&nbsp;    private final TimedLock&lt;Boolean&gt; lobbyLock = new TimedLock&lt;&gt;(false);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This constructor builds an instance that uses the given game model and gameClosed callback,
&nbsp;     * it is initialized with empty user, player and observer association
&nbsp;     *
&nbsp;     * @param game               The game model that the game controller need to use
&nbsp;     * @param gameClosedCallback The gameClosed callback
&nbsp;     */
&nbsp;    public StandardGameController(Game game, Consumer&lt;? super LobbyController&gt; gameClosedCallback) {
<b class="fc">&nbsp;        super();</b>
<b class="fc">&nbsp;        this.game = game;</b>
<b class="fc">&nbsp;        this.gameClosedCallback = gameClosedCallback;</b>
<b class="fc">&nbsp;        this.userAssociation = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        this.playerAssociation = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        this.observerAssociation = new HashMap&lt;&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    ///LOBBY CONTROLLER/////////////////////
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     *
&nbsp;     * @param newClient The client that needs to be attached to the game
&nbsp;     * @param newUser   The user reference of the client into the server
&nbsp;     * @param playerId  The new player ID
&nbsp;     * @throws GameAccessDeniedException if the game is already ended or the player id already exists or the matchmaking is closed
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void joinPlayer(ClientInterface newClient, User newUser, String playerId) throws GameAccessDeniedException {
<b class="fc">&nbsp;        synchronized (this.lobbyLock) {</b>
&nbsp;            try {
&nbsp;                /* Get model status before the player joins*/
<b class="fc">&nbsp;                Game.GameStatus previousStatus = this.game.getGameStatus();</b>
&nbsp;
&nbsp;                /* Try to join the player */
<b class="fc">&nbsp;                this.game.addPlayer(playerId);</b>
&nbsp;
&nbsp;                /* Attach all the observers to the client */
&nbsp;                try {
<b class="fc">&nbsp;                    this.addObservers(newClient, playerId);</b>
<b class="nc">&nbsp;                } catch (PlayerNotExistsException e) {</b>
<b class="nc">&nbsp;                    this.printModelError(&quot;Player that should exists does not exists, warning due to possible malfunctions&quot;);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /* Authorize the client to use this controller*/
<b class="fc">&nbsp;                this.userAssociation.put(newClient, newUser);</b>
&nbsp;
&nbsp;                /* Put newUser into known users */
<b class="fc">&nbsp;                this.playerAssociation.put(newUser, playerId);</b>
&nbsp;
&nbsp;                /* Get model status after the player has joined */
<b class="fc">&nbsp;                Game.GameStatus newStatus = this.game.getGameStatus();</b>
&nbsp;
<b class="fc">&nbsp;                if (previousStatus == Game.GameStatus.SUSPENDED) {</b>
&nbsp;                    /* If the model was in suspended status then notify to resume the game */
<b class="fc">&nbsp;                    this.lobbyLock.unlock(true);</b>
&nbsp;
<b class="fc">&nbsp;                } else if (previousStatus == Game.GameStatus.MATCHMAKING &amp;&amp; newStatus == Game.GameStatus.STARTED) {</b>
&nbsp;                    /* If game is ready to be started we force the first turn*/
<b class="fc">&nbsp;                    this.game.getLivingRoom().refillBoard();</b>
<b class="fc">&nbsp;                    this.game.updatePlayersTurn();</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;            } catch (PlayerAlreadyExistsException e) {</b>
<b class="fc">&nbsp;                throw new GameAccessDeniedException(&quot;Player id already exists&quot;);</b>
<b class="fc">&nbsp;            } catch (MatchmakingClosedException | GameEndedException e) {</b>
<b class="fc">&nbsp;                throw new GameAccessDeniedException(&quot;Game matchmaking closed&quot;);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add observers to all needed observable model objects
&nbsp;     *
&nbsp;     * @param newClient   new player&#39;s ClientInterface
&nbsp;     * @param newPlayerId new player&#39;s id
&nbsp;     * @throws PlayerNotExistsException if the player does not exists
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;rawtypes&quot;)
&nbsp;    private void addObservers(ClientInterface newClient, String newPlayerId) throws PlayerNotExistsException {
&nbsp;        /* Creates a map to associate each observer to his observable */
<b class="fc">&nbsp;        Map&lt;Observable, Observer&gt; newObserverAssociation = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        Player newPlayer = this.game.getPlayer(newPlayerId);</b>
&nbsp;
&nbsp;        /* Add Player status observer */
<b class="fc">&nbsp;        Observer&lt;Player, Player.Event&gt; playerEventObservable = this.getPlayerObserver(newClient);</b>
<b class="fc">&nbsp;        newObserverAssociation.put(newPlayer, playerEventObservable);</b>
<b class="fc">&nbsp;        newPlayer.addObserver(playerEventObservable);</b>
&nbsp;
&nbsp;        /* Add Game status observer */
<b class="fc">&nbsp;        Observer&lt;Game, Game.Event&gt; gameEventObserver = this.getGameObserver(newClient);</b>
<b class="fc">&nbsp;        newObserverAssociation.put(this.game, gameEventObserver);</b>
<b class="fc">&nbsp;        this.game.addObserver(gameEventObserver);</b>
&nbsp;
&nbsp;        /* Add CommonGoal status observers */
<b class="fc">&nbsp;        this.game.getCommonGoals().forEach(goal -&gt; {</b>
<b class="fc">&nbsp;                    Observer&lt;CommonGoal, CommonGoal.Event&gt; commonGoalEventObserver = this.getCommonGoalObserver(newClient);</b>
<b class="fc">&nbsp;                    newObserverAssociation.put(goal, commonGoalEventObserver);</b>
<b class="fc">&nbsp;                    goal.addObserver(commonGoalEventObserver);</b>
&nbsp;                }
&nbsp;        );
&nbsp;
&nbsp;        /* Add LivingRoom status observer */
<b class="fc">&nbsp;        LivingRoom livingRoom = this.game.getLivingRoom();</b>
<b class="fc">&nbsp;        Observer&lt;LivingRoom, LivingRoom.Event&gt; livingRoomEventObserver = this.getLivingRoomObserver(newClient);</b>
<b class="fc">&nbsp;        newObserverAssociation.put(livingRoom, livingRoomEventObserver);</b>
<b class="fc">&nbsp;        livingRoom.addObserver(livingRoomEventObserver);</b>
&nbsp;
&nbsp;        /* Add PlayerChat status observer */
<b class="fc">&nbsp;        PlayerChat playerChat = newPlayer.getPlayerChat();</b>
<b class="fc">&nbsp;        Observer&lt;PlayerChat, PlayerChat.Event&gt; playerChatEventObserver = this.getPlayerChatObserver(newClient);</b>
<b class="fc">&nbsp;        newObserverAssociation.put(playerChat, playerChatEventObserver);</b>
<b class="fc">&nbsp;        playerChat.addObserver(playerChatEventObserver);</b>
&nbsp;
&nbsp;        /* Add PersonalGoals status observer */
<b class="fc">&nbsp;        newPlayer.getPersonalGoals().forEach(personalGoal -&gt; {</b>
<b class="fc">&nbsp;            Observer&lt;PersonalGoal, PersonalGoal.Event&gt; personalGoalEventObserver = this.getPersonalGoalObserver(newClient);</b>
<b class="fc">&nbsp;            newObserverAssociation.put(personalGoal, personalGoalEventObserver);</b>
<b class="fc">&nbsp;            personalGoal.addObserver(personalGoalEventObserver);</b>
&nbsp;        });
&nbsp;
&nbsp;        /* Add Shelf status observer */
<b class="fc">&nbsp;        Shelf newPlayerShelf = newPlayer.getShelf();</b>
<b class="fc">&nbsp;        Observer&lt;Shelf, Shelf.Event&gt; shelfEventObserver = this.getShelfObserver(newClient, newPlayerId);</b>
<b class="fc">&nbsp;        newObserverAssociation.put(newPlayerShelf, shelfEventObserver);</b>
<b class="fc">&nbsp;        newPlayerShelf.addObserver(this.getShelfObserver(newClient, newPlayerId));</b>
&nbsp;
&nbsp;        /* Add Shelf status observer of new player to all already joined players */
&nbsp;        /* Add Shelf status observer of all already joined players to new player */
<b class="fc">&nbsp;        for (Map.Entry&lt;ClientInterface, User&gt; association : this.userAssociation.entrySet()) {</b>
<b class="fc">&nbsp;            Observer&lt;Shelf, Shelf.Event&gt; newPlayerShelfEventObserver = this.getShelfObserver(association.getKey(), newPlayerId);</b>
<b class="fc">&nbsp;            newPlayerShelf.addObserver(newPlayerShelfEventObserver);</b>
<b class="fc">&nbsp;            this.observerAssociation.get(association.getKey()).put(newPlayerShelf,newPlayerShelfEventObserver);</b>
&nbsp;
<b class="fc">&nbsp;            String joinedPlayerId = this.playerAssociation.get(association.getValue());</b>
<b class="fc">&nbsp;            Shelf joinedPlayerShelf = this.game.getPlayer(joinedPlayerId).getShelf();</b>
&nbsp;
<b class="fc">&nbsp;            Observer&lt;Shelf, Shelf.Event&gt; joinedPlayerShelfEventObserver = this.getShelfObserver(newClient, joinedPlayerId);</b>
<b class="fc">&nbsp;            newObserverAssociation.put(joinedPlayerShelf, joinedPlayerShelfEventObserver);</b>
<b class="fc">&nbsp;            joinedPlayerShelf.addObserver(joinedPlayerShelfEventObserver);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        /* Associate the observers to the client they are updating */
<b class="fc">&nbsp;        this.observerAssociation.put(newClient, newObserverAssociation);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Observer to update the PlayerInfo
&nbsp;     *
&nbsp;     * @param newClient client to be added
&nbsp;     * @return Player&#39;s Observer to be added
&nbsp;     */
&nbsp;    private Observer&lt;Player, Player.Event&gt; getPlayerObserver(ClientInterface newClient) {
<b class="fc">&nbsp;        return new Observer&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void update(Player o, Player.Event arg) {
&nbsp;                try {
<b class="fc">&nbsp;                    newClient.update(o.getInfo(), arg);</b>
<b class="fc">&nbsp;                } catch (RemoteException e) {</b>
<b class="fc">&nbsp;                    o.deleteObserver(this);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Observer to update the GameStatus
&nbsp;     *
&nbsp;     * @param newClient client to be added
&nbsp;     * @return Observer of the GameStatus to be added
&nbsp;     */
&nbsp;    private Observer&lt;Game, Game.Event&gt; getGameObserver(ClientInterface newClient) {
<b class="fc">&nbsp;        return new Observer&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void update(Game o, Game.Event arg) {
&nbsp;                try {
<b class="fc">&nbsp;                    newClient.update(o.getInfo(), arg);</b>
<b class="fc">&nbsp;                } catch (RemoteException e) {</b>
<b class="fc">&nbsp;                    o.deleteObserver(this);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Observer to update the CommonGoal
&nbsp;     *
&nbsp;     * @param newClient client to be added
&nbsp;     * @return Observer of the CommonGoal to be added
&nbsp;     */
&nbsp;
&nbsp;    private Observer&lt;CommonGoal, CommonGoal.Event&gt; getCommonGoalObserver(ClientInterface newClient) {
<b class="fc">&nbsp;        return new Observer&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void update(CommonGoal o, CommonGoal.Event arg) {
&nbsp;                try {
<b class="fc">&nbsp;                    newClient.update(o.getInfo(), arg);</b>
<b class="fc">&nbsp;                } catch (RemoteException e) {</b>
<b class="fc">&nbsp;                    System.err.println(&quot;Distribution: unable to update observer -&gt; detaching commonGoal observer&quot;);</b>
<b class="fc">&nbsp;                    o.deleteObserver(this);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Observer to update the LivingRoom
&nbsp;     *
&nbsp;     * @param newClient client to be added
&nbsp;     * @return Observer of the LivingRoom to be added
&nbsp;     */
&nbsp;
&nbsp;    private Observer&lt;LivingRoom, LivingRoom.Event&gt; getLivingRoomObserver(ClientInterface newClient) {
<b class="fc">&nbsp;        return new Observer&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void update(LivingRoom o, LivingRoom.Event arg) {
&nbsp;                try {
<b class="fc">&nbsp;                    newClient.update(o.getInfo(), arg);</b>
<b class="fc">&nbsp;                } catch (RemoteException e) {</b>
<b class="fc">&nbsp;                    System.err.println(&quot;Distribution: unable to update observer -&gt; detaching livingRoom observer&quot;);</b>
<b class="fc">&nbsp;                    o.deleteObserver(this);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Observer to update the PlayerChat
&nbsp;     *
&nbsp;     * @param newClient client to be added
&nbsp;     * @return Observer of the PlayerChat to be added
&nbsp;     */
&nbsp;
&nbsp;    private Observer&lt;PlayerChat, PlayerChat.Event&gt; getPlayerChatObserver(ClientInterface newClient) {
<b class="fc">&nbsp;        return new Observer&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void update(PlayerChat o, PlayerChat.Event arg) {
&nbsp;                try {
<b class="fc">&nbsp;                    newClient.update(o.getInfo(), arg);</b>
<b class="fc">&nbsp;                } catch (RemoteException e) {</b>
<b class="fc">&nbsp;                    System.err.println(&quot;Distribution: unable to update observer -&gt; detaching playerChat observer&quot;);</b>
<b class="fc">&nbsp;                    o.deleteObserver(this);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Observer to update the PersonalGoal
&nbsp;     *
&nbsp;     * @param newClient client to be added
&nbsp;     * @return Observer of the PersonalGoal to be added
&nbsp;     */
&nbsp;
&nbsp;    private Observer&lt;PersonalGoal, PersonalGoal.Event&gt; getPersonalGoalObserver(ClientInterface newClient) {
<b class="fc">&nbsp;        return new Observer&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void update(PersonalGoal o, PersonalGoal.Event arg) {
&nbsp;                try {
<b class="fc">&nbsp;                    newClient.update(o.getInfo(), arg);</b>
<b class="fc">&nbsp;                } catch (RemoteException e) {</b>
<b class="fc">&nbsp;                    System.err.println(&quot;Distribution: unable to update observer -&gt; detaching personalGoal observer&quot;);</b>
<b class="fc">&nbsp;                    o.deleteObserver(this);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Observer to update the Shelf
&nbsp;     *
&nbsp;     * @param newClient client to be added
&nbsp;     * @param joinedPlayerId id of the player to be added
&nbsp;     * @return Observer of the Shelf to be added
&nbsp;     */
&nbsp;
&nbsp;    private Observer&lt;Shelf, Shelf.Event&gt; getShelfObserver(ClientInterface newClient, String joinedPlayerId) {
<b class="fc">&nbsp;        return new Observer&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void update(Shelf o, Shelf.Event arg) {
&nbsp;                try {
<b class="fc">&nbsp;                    newClient.update(o.getInfo(joinedPlayerId), arg);</b>
<b class="fc">&nbsp;                } catch (RemoteException e) {</b>
<b class="fc">&nbsp;                    System.err.println(&quot;Distribution: unable to update observer -&gt; detaching shelf observer&quot;);</b>
<b class="fc">&nbsp;                    o.deleteObserver(this);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     *
&nbsp;     * @param client {@inheritDoc}
&nbsp;     * @throws GameAccessDeniedException if client has not joined this game
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;rawtypes&quot;)
&nbsp;    @Override
&nbsp;    public void leavePlayer(ClientInterface client) throws GameAccessDeniedException {
&nbsp;        /* Check if client is allowed */
<b class="fc">&nbsp;        if (!this.userAssociation.containsKey(client))</b>
<b class="fc">&nbsp;            throw new GameAccessDeniedException(&quot;Unknown client&quot;);</b>
&nbsp;
&nbsp;        /* Take lobbyLock */
<b class="fc">&nbsp;        synchronized (this.lobbyLock) {</b>
&nbsp;            /* remove User to allowed */
<b class="fc">&nbsp;            User leavedUser = this.userAssociation.remove(client);</b>
&nbsp;
&nbsp;            /* remove all observer associated with this user */
<b class="fc">&nbsp;            Map&lt;Observable, Observer&gt; playerObserverAssociation = this.observerAssociation.get(client);</b>
&nbsp;
<b class="fc">&nbsp;            playerObserverAssociation.forEach(Observable::deleteObserver);</b>
&nbsp;
&nbsp;            /* Reports to the user it has leaved the game */
<b class="fc">&nbsp;            leavedUser.reportEvent(User.Status.NOT_JOINED, &quot;Player leaved&quot;, User.Event.GAME_LEAVED);</b>
&nbsp;
<b class="fc">&nbsp;            if (this.game.getGameStatus() == Game.GameStatus.MATCHMAKING)</b>
&nbsp;                /* If the game is Matchmaking then directly close the game */
<b class="fc">&nbsp;                this.closeTheGame(&quot;Game closed due to disconnection while matchmaking&quot;);</b>
&nbsp;
<b class="fc">&nbsp;            else if (this.game.getGameStatus() == Game.GameStatus.SUSPENDED) {</b>
&nbsp;                /* If the game was suspended then notify to close the game */
<b class="nc">&nbsp;                this.lobbyLock.unlock(false);</b>
&nbsp;
<b class="fc">&nbsp;            } else if (this.game.getGameStatus() == Game.GameStatus.STARTED) {</b>
&nbsp;                /* If the game is running then remove the player */
&nbsp;                try {
&nbsp;                    /* Get the playerID */
<b class="fc">&nbsp;                    String leavedPlayer = this.playerAssociation.remove(leavedUser);</b>
&nbsp;
&nbsp;                    /* Evaluate if game needs a turn-skip (is player who leaved has the turn) */
<b class="fc">&nbsp;                    boolean skipNeeded = this.game.getTurnPlayerId().equals(leavedPlayer);</b>
&nbsp;
&nbsp;                    /* Remove player on model side */
<b class="fc">&nbsp;                    this.game.removePlayer(leavedPlayer);</b>
&nbsp;
&nbsp;                    /* If model signal SUSPENDED status then run a timer */
<b class="fc">&nbsp;                    if (this.game.getGameStatus() == Game.GameStatus.SUSPENDED) {</b>
<b class="fc">&nbsp;                        new Thread(() -&gt; {</b>
&nbsp;                            /* Timer wait 6 seconds for a player to rejoin */
<b class="fc">&nbsp;                            this.lobbyLock.reset(false);</b>
<b class="fc">&nbsp;                            if (!this.lobbyLock.hasBeenUnlocked())</b>
&nbsp;                                try {
<b class="fc">&nbsp;                                    this.lobbyLock.lock(6000);</b>
<b class="nc">&nbsp;                                } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                                    System.err.println(&quot;GameController: Timer is not working as intended&quot;);</b>
<b class="fc">&nbsp;                                }</b>
&nbsp;
&nbsp;                            /* If nobody has rejoined then close the game */
<b class="fc">&nbsp;                            if (!this.lobbyLock.getValue())</b>
<b class="fc">&nbsp;                                this.closeTheGame(&quot;Game closed due to reconnection timeout&quot;);</b>
&nbsp;                            else
&nbsp;                            {
<b class="fc">&nbsp;                                if (skipNeeded) {</b>
&nbsp;                                    try {
<b class="fc">&nbsp;                                        this.game.updatePlayersTurn();</b>
<b class="nc">&nbsp;                                    } catch (GameEndedException e) {</b>
&nbsp;                                        /* If skipping the turn makes game end, then close the game */
<b class="nc">&nbsp;                                        this.closeTheGame(&quot;Game Ended&quot;);</b>
<b class="fc">&nbsp;                                    }</b>
&nbsp;                                }
&nbsp;                            }
<b class="fc">&nbsp;                        }).start();</b>
&nbsp;                    }
&nbsp;                    /* If a skip was needed then skip the turn */
<b class="nc">&nbsp;                    else if (skipNeeded) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            this.game.updatePlayersTurn();</b>
<b class="nc">&nbsp;                        } catch (GameEndedException e) {</b>
&nbsp;                            /* If skipping the turn makes game end, then close the game */
<b class="nc">&nbsp;                            this.closeTheGame(&quot;Game Ended&quot;);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (PlayerNotExistsException e) {</b>
<b class="nc">&nbsp;                    this.printModelError(&quot;Player should exists but does not exists, skipping player deletion...&quot;);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method permanently closes the game, detaches all the clients and calls the gameClosed callback, sends the given message to all connected users
&nbsp;     *
&nbsp;     * @param message The message that needs to be sent to the connected users
&nbsp;     */
&nbsp;    private void closeTheGame(String message) {
&nbsp;        /* Reports to all connected user they left the game */
<b class="fc">&nbsp;        for (User u : this.userAssociation.values()) {</b>
<b class="fc">&nbsp;            u.reportEvent(User.Status.NOT_JOINED, message, User.Event.GAME_LEAVED);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        /* Remove all allowed user */
<b class="fc">&nbsp;        this.userAssociation.clear();</b>
&nbsp;
&nbsp;        /* Signal the model to definitely end the game */
<b class="fc">&nbsp;        this.game.close();</b>
&nbsp;        /* Detach all the observers from the model */
<b class="fc">&nbsp;        this.game.deleteObservers();</b>
<b class="fc">&nbsp;        this.game.getCommonGoals().forEach(Observable::deleteObservers);</b>
<b class="fc">&nbsp;        this.game.getLivingRoom().deleteObservers();</b>
<b class="fc">&nbsp;        for (String playerId : this.playerAssociation.values()) {</b>
&nbsp;            try {
<b class="fc">&nbsp;                Player p = this.game.getPlayer(playerId);</b>
<b class="fc">&nbsp;                p.deleteObservers();</b>
<b class="fc">&nbsp;                p.getPlayerChat().deleteObservers();</b>
<b class="fc">&nbsp;                p.getPersonalGoals().forEach(Observable::deleteObservers);</b>
<b class="fc">&nbsp;                p.getShelf().deleteObservers();</b>
<b class="nc">&nbsp;            } catch (PlayerNotExistsException e) {</b>
<b class="nc">&nbsp;                this.printModelError(&quot;Player should exists but does not exists, skipping observer deletion....&quot;);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        /* Calls gameClosedCallback to signal this controller is no longer useful */
<b class="fc">&nbsp;        this.gameClosedCallback.accept(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     *
&nbsp;     * @param client     {@inheritDoc}
&nbsp;     * @param playerMove {@inheritDoc}
&nbsp;     */
&nbsp;    public synchronized void doPlayerMove(ClientInterface client, PlayerMoveInfo playerMove) {
&nbsp;        /* Check if client is allowed */
<b class="fc">&nbsp;        if (!this.userAssociation.containsKey(client))</b>
<b class="fc">&nbsp;            System.err.println(&quot;GameController: Command from unauthenticated client&quot;);</b>
&nbsp;        else {
&nbsp;            /* get id associated with allowed client */
<b class="fc">&nbsp;            String playerId = this.playerAssociation.get(this.userAssociation.get(client));</b>
&nbsp;
&nbsp;            try {
&nbsp;                /* Get player information associated with his client */
<b class="fc">&nbsp;                Player player = this.game.getPlayer(playerId);</b>
&nbsp;
<b class="fc">&nbsp;                if (this.game.getGameStatus() != Game.GameStatus.STARTED)</b>
&nbsp;                    /* If game is not started we discard the request */
<b class="fc">&nbsp;                    player.reportError(&quot;Game not started yet&quot;);</b>
&nbsp;
<b class="fc">&nbsp;                else if (!playerId.equals(this.game.getTurnPlayerId()))</b>
&nbsp;                    /* If it isn&#39;t player turn we discard the request*/
<b class="fc">&nbsp;                    player.reportError(&quot;Not your turn&quot;);</b>
&nbsp;
&nbsp;                else {
&nbsp;                    /* Get board and player shelf status */
<b class="fc">&nbsp;                    Tile[][] shelf = player.getShelf().getTiles();</b>
<b class="fc">&nbsp;                    Tile[][] board = this.game.getLivingRoom().getBoard();</b>
&nbsp;
&nbsp;                    try {
&nbsp;                        /* Check if move object is well-formed and contains coherent info */
<b class="fc">&nbsp;                        this.checkWellFormedMove(playerMove, shelf, board);</b>
&nbsp;
&nbsp;                        /* Foreach tile we pick it from board and put it on the shelf */
<b class="fc">&nbsp;                        for (PickedTile tile : playerMove.pickedTiles()) {</b>
<b class="fc">&nbsp;                            Tile picked = board[tile.row()][tile.col()];</b>
<b class="fc">&nbsp;                            board[tile.row()][tile.col()] = Tile.EMPTY;</b>
<b class="fc">&nbsp;                            this.insertTileInShelf(playerMove.columnToInsert(), shelf, picked);</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        /* Update board and player shelf status*/
<b class="fc">&nbsp;                        this.game.getLivingRoom().setBoard(board);</b>
<b class="fc">&nbsp;                        this.game.getLivingRoom().refillBoard();</b>
<b class="fc">&nbsp;                        player.getShelf().setTiles(shelf);</b>
&nbsp;
&nbsp;                        /* If player shelf has been filled we signal that this will be the last round of turns */
<b class="fc">&nbsp;                        if (this.evaluateFullShelf(shelf)) {</b>
&nbsp;                            /* If nobody else has already completed the shelf we assign a &quot;GAME_END&quot; token */
<b class="fc">&nbsp;                            if (!this.game.isLastTurn())</b>
<b class="fc">&nbsp;                                player.addAchievedCommonGoal(&quot;First player that have completed the shelf&quot;, Token.TOKEN_GAME_END);</b>
&nbsp;
<b class="fc">&nbsp;                            this.game.setLastTurn();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /* Check if player has achieved common goals */
<b class="fc">&nbsp;                        for (CommonGoal commonGoal : this.game.getCommonGoals())</b>
<b class="fc">&nbsp;                            if (!player.getAchievedCommonGoals().containsKey(commonGoal.getEvaluator().getId()))</b>
<b class="fc">&nbsp;                                if (commonGoal.getEvaluator().evaluate(shelf)) {</b>
<b class="fc">&nbsp;                                    player.addAchievedCommonGoal(commonGoal.getEvaluator().getId(), commonGoal.popToken());</b>
&nbsp;                                }
&nbsp;
&nbsp;
&nbsp;                        /* Check if player has achieved personal goals*/
<b class="fc">&nbsp;                        for (PersonalGoal personalGoal : player.getPersonalGoals()) {</b>
<b class="fc">&nbsp;                            if (!personalGoal.isAchieved())</b>
<b class="fc">&nbsp;                                if (personalGoal.evaluate(shelf))</b>
<b class="fc">&nbsp;                                    personalGoal.setAchieved();</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        /* Pass turn to next player */
&nbsp;                        try {
<b class="fc">&nbsp;                            this.game.updatePlayersTurn();</b>
<b class="fc">&nbsp;                        } catch (GameEndedException e) {</b>
&nbsp;                            /* If skipping the turn makes game end, then close the game */
<b class="fc">&nbsp;                            this.closeTheGame(&quot;Game Ended&quot;);</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;
<b class="fc">&nbsp;                    } catch (IllegalArgumentException e) {</b>
<b class="fc">&nbsp;                        player.reportError(&quot;Malformed move: &quot; + e.getMessage());</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (PlayerNotExistsException ex) {</b>
<b class="nc">&nbsp;                this.printModelError(&quot;Player should exists but does not exists, skipping player interaction...&quot;);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     *
&nbsp;     * @param client     {@inheritDoc}
&nbsp;     * @param newMessage {@inheritDoc}
&nbsp;     */
&nbsp;    public synchronized void sendMessage(ClientInterface client, Message newMessage) {
&nbsp;        /* Check if client is allowed */
<b class="fc">&nbsp;        if (!this.userAssociation.containsKey(client))</b>
<b class="fc">&nbsp;            System.err.println(&quot;GameController: Command from unauthenticated client&quot;);</b>
&nbsp;        else {
&nbsp;            /* get playerId associated with allowed client */
<b class="fc">&nbsp;            String senderId = this.playerAssociation.get(this.userAssociation.get(client));</b>
&nbsp;            try {
&nbsp;                /* get player object associated with senderId */
<b class="fc">&nbsp;                Player sender = this.game.getPlayer(senderId);</b>
&nbsp;
&nbsp;                /* Checks if client and message sender info are coherent*/
<b class="fc">&nbsp;                if (!newMessage.getSender().equals(senderId))</b>
<b class="nc">&nbsp;                    sender.reportError(&quot;Sender of the message is not the same of message info&quot;);</b>
&nbsp;
&nbsp;                    /* If subject is not a player of this game then send an error */
<b class="fc">&nbsp;                else if (!(newMessage.getReceiver().isEmpty() || this.playerAssociation.containsValue(newMessage.getReceiver())))</b>
<b class="fc">&nbsp;                    sender.reportError(&quot;Subject of the message does not exists&quot;);</b>
&nbsp;
&nbsp;                    /* If subject is a player or all players send message */
&nbsp;                else {
<b class="fc">&nbsp;                    for (String playerId : this.playerAssociation.values()) {</b>
&nbsp;                        /* Send the message to all if receiver is empty or only to sender or receiver if specified */
<b class="fc">&nbsp;                        if (newMessage.getReceiver().isEmpty() || newMessage.getReceiver().equals(playerId) || newMessage.getSender().equals(playerId))</b>
<b class="fc">&nbsp;                            this.game.getPlayer(playerId).getPlayerChat().addMessage(newMessage);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (PlayerNotExistsException e) {</b>
<b class="nc">&nbsp;                this.printModelError(&quot;Player should exists but does not exists, skipping message sending&quot;);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method checks if the given move is legal or illegal
&nbsp;     *
&nbsp;     * @param playerMove The move that needs to be checked
&nbsp;     * @param shelf      The player shelf the move is referred
&nbsp;     * @param board      The living room board the move is referred
&nbsp;     * @throws IllegalArgumentException If move is illegal
&nbsp;     */
&nbsp;    private void checkWellFormedMove(PlayerMoveInfo playerMove, Tile[][] shelf, Tile[][] board) throws IllegalArgumentException {
&nbsp;        /* Do some checks on &quot;move&quot; object, if malformed we discard it */
<b class="fc">&nbsp;        if (playerMove == null || playerMove.pickedTiles() == null || playerMove.pickedTiles().size() == 0)</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Malformed move object&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        if (playerMove.columnToInsert() &lt; 0 || playerMove.columnToInsert() &gt; shelf[0].length - 1)</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Column index out of bounds&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        if (!this.areTilesDifferent(new ArrayList&lt;&gt;(playerMove.pickedTiles())))</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Tiles are not different&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        if (!this.areTilesAligned(new ArrayList&lt;&gt;(playerMove.pickedTiles())))</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Tiles are not aligned&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        for (PickedTile tile : playerMove.pickedTiles())</b>
<b class="fc">&nbsp;            if (!this.isTilePickable(tile.row(), tile.col(), board))</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Tile not pickable&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        if (playerMove.pickedTiles().size() &gt; this.freeShelfColumnSpaces(playerMove.columnToInsert(), shelf))</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Not enough space to insert tiles in shelf&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * This method checks whether the picked tiles are the same or not
&nbsp;     *
&nbsp;     * @param pickedTiles list of picked tiles
&nbsp;     * @return true if tiles are different, false otherwise
&nbsp;     */
&nbsp;    private boolean areTilesDifferent(List&lt;PickedTile&gt; pickedTiles) {
<b class="fc">&nbsp;        for (int i = 0; i &lt; pickedTiles.size(); i++) {</b>
<b class="fc">&nbsp;            for (int j = i + 1; j &lt; pickedTiles.size(); j++) {</b>
<b class="fc">&nbsp;                if (pickedTiles.get(i).row() == pickedTiles.get(j).row())</b>
<b class="fc">&nbsp;                    if (pickedTiles.get(i).col() == pickedTiles.get(j).col())</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Given a column of a player shelf this method counts the number of free spaces
&nbsp;     *
&nbsp;     * @param column column to check
&nbsp;     * @param shelf  player shelf
&nbsp;     * @return number of free spaces in the column
&nbsp;     */
&nbsp;    private int freeShelfColumnSpaces(int column, Tile[][] shelf) {
<b class="fc">&nbsp;        int spaces = 0;</b>
<b class="fc">&nbsp;        for (Tile[] row : shelf) {</b>
<b class="fc">&nbsp;            if (row[column] == Tile.EMPTY)</b>
<b class="fc">&nbsp;                spaces++;</b>
&nbsp;        }
<b class="fc">&nbsp;        return spaces;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method inserts the picked tiles in the shelf
&nbsp;     *
&nbsp;     * @param column column to check
&nbsp;     * @param shelf  player shelf
&nbsp;     * @param tile   tile to insert
&nbsp;     */
&nbsp;    private void insertTileInShelf(int column, Tile[][] shelf, Tile tile) {
<b class="fc">&nbsp;        int row = shelf.length - 1;</b>
<b class="fc">&nbsp;        while (shelf[row][column] != Tile.EMPTY)</b>
<b class="fc">&nbsp;            row--;</b>
&nbsp;
<b class="fc">&nbsp;        shelf[row][column] = tile;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method checks whether the selected tile is pickable or not
&nbsp;     *
&nbsp;     * @param row    row of the tile
&nbsp;     * @param column column of the tile
&nbsp;     * @param board  board to check
&nbsp;     * @return true if tile is pickable, false otherwise
&nbsp;     */
&nbsp;    private boolean isTilePickable(int row, int column, Tile[][] board) {
<b class="fc">&nbsp;        if (row &lt; 0 || column &lt; 0 || row &gt; board.length - 1 || column &gt; board[row].length - 1 || board[row][column] == Tile.EMPTY || board[row][column] == null)</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;
<b class="fc">&nbsp;        if (row == 0 || column == 0 || row == board.length - 1 || column == board[0].length - 1)</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;
<b class="fc">&nbsp;        return board[row - 1][column] == Tile.EMPTY</b>
&nbsp;                || board[row + 1][column] == Tile.EMPTY
&nbsp;                || board[row][column - 1] == Tile.EMPTY
&nbsp;                || board[row][column + 1] == Tile.EMPTY;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method checks whether the shelf is full or not
&nbsp;     *
&nbsp;     * @param shelf shelf to check
&nbsp;     * @return true if shelf is full, false otherwise
&nbsp;     */
&nbsp;    private boolean evaluateFullShelf(Tile[][] shelf) {
<b class="fc">&nbsp;        for (Tile[] row : shelf)</b>
<b class="fc">&nbsp;            for (Tile tile : row)</b>
<b class="fc">&nbsp;                if (tile == Tile.EMPTY)</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method checks whether the picked tiles are aligned or not
&nbsp;     *
&nbsp;     * @param pickedTiles Tiles picked from board
&nbsp;     * @return true if picked tiles are aligned ad adjacent one another
&nbsp;     */
&nbsp;    private boolean areTilesAligned(List&lt;PickedTile&gt; pickedTiles) {
<b class="fc">&nbsp;        boolean rowAligned = true;</b>
<b class="fc">&nbsp;        boolean colAligned = true;</b>
&nbsp;
<b class="fc">&nbsp;        for (int i = 1; i &lt; pickedTiles.size(); i++) {</b>
<b class="fc">&nbsp;            rowAligned = rowAligned &amp;&amp; (pickedTiles.get(i - 1).row() == pickedTiles.get(i).row());</b>
<b class="fc">&nbsp;            colAligned = colAligned &amp;&amp; (pickedTiles.get(i - 1).col() == pickedTiles.get(i).col());</b>
&nbsp;        }
<b class="fc">&nbsp;        if (rowAligned) {</b>
<b class="fc">&nbsp;            pickedTiles.sort(Comparator.comparingInt(PickedTile::col));</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; pickedTiles.size() - 1; i++)</b>
<b class="fc">&nbsp;                if (pickedTiles.get(i).col() + 1 != pickedTiles.get(i + 1).col())</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (colAligned) {</b>
<b class="fc">&nbsp;            pickedTiles.sort(Comparator.comparingInt(PickedTile::row));</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; pickedTiles.size() - 1; i++)</b>
<b class="fc">&nbsp;                if (pickedTiles.get(i).row() + 1 != pickedTiles.get(i + 1).row())</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;        }
&nbsp;
&nbsp;
<b class="fc">&nbsp;        return rowAligned || colAligned;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method prints an error on server console if an error occurred on model manipulation
&nbsp;     *
&nbsp;     * @param message The message that needs to be print
&nbsp;     */
&nbsp;    private void printModelError(String message) {
<b class="nc">&nbsp;        System.err.println(&quot;GameController: ModelError: &quot; + message);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-06-29 19:37</div>
</div>
</body>
</html>
